/*
  3dfier: takes 2D GIS datasets and "3dfies" to create 3D city models.

  Copyright (C) 2015-2020 3D geoinformation research group, TU Delft

  This file is part of 3dfier.

  3dfier is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  3dfier is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with 3difer.  If not, see <http://www.gnu.org/licenses/>.

  For any information or further details about the use of 3dfier, contact
  Hugo Ledoux
  <h.ledoux@tudelft.nl>
  Faculty of Architecture & the Built Environment
  Delft University of Technology
  Julianalaan 134, Delft 2628BL, the Netherlands
*/

#ifndef __3DFIER__TopoFeature__
#define __3DFIER__TopoFeature__

#include "definitions.h"
#include "geomtools.h"
#include "io.h"
#include "polyfit.hpp"
#include "nlohmann-json/json.hpp"

class TopoFeature {
public:
  TopoFeature(char *wkt, std::string layername, AttributeMap attributes, std::string pid);
  ~TopoFeature();

  virtual bool          lift() = 0;
  virtual bool          buildCDT();
  virtual bool          add_elevation_point(Point2& p, double z, float radius, int lasclass, bool within) = 0;
  virtual int           get_number_vertices() = 0;
  virtual TopoClass     get_class() = 0;
  virtual bool          is_hard() = 0;
  virtual std::string   get_mtl() = 0;
  virtual void          get_citygml(std::wostream& of) = 0;
  virtual void          get_cityjson(nlohmann::json& j, std::unordered_map<std::string, unsigned long>& dPts) = 0;
  virtual void          get_citygml_imgeo(std::wostream& of) = 0;
  virtual bool          get_shape(OGRLayer*, bool writeAttributes, const AttributeMap& extraAttributes = AttributeMap()) = 0;
  virtual void          cleanup_elevations() = 0;

  std::string  get_id();
  void         construct_vertical_walls(const NodeColumn& nc);
  void         fix_bowtie();
  void         add_adjacent_feature(TopoFeature* adjFeature);
  std::vector<TopoFeature*>* get_adjacent_features();
  Polygon2*    get_Polygon2();
  Box2         get_bbox2d();
  std::string  get_layername();
  Point2       get_point2(int ringi, int pi);
  bool         has_point2(const Point2& p, std::vector<int>& ringis, std::vector<int>& pis);
  bool         has_segment(const Point2& a, const Point2& b, int& aringi, int& api, int& bringi, int& bpi);
  bool         adjacent(Polygon2& poly);
  float        get_distance_to_boundaries(const Point2& p);
  int          get_vertex_elevation(int ringi, int pi);
  int          get_vertex_elevation(const Point2& p);
  void         set_vertex_elevation(int ringi, int pi, int z);
  void         set_top_level(bool toplevel);
  bool         has_vertical_walls();
  void         add_vertical_wall();
  bool         get_top_level();
  bool         get_multipolygon_features(OGRLayer* layer, std::string className, bool writeAttributes, const AttributeMap& extraAttributes = AttributeMap());
  bool         writeAttribute(OGRFeature* feature, OGRFeatureDefn* featureDefn, std::string name, std::string value);
  void         get_obj(std::unordered_map< std::string, unsigned long >& dPts, std::string mtl, std::string& fs);
  void         get_stl(std::unordered_map< std::string, unsigned long >& dPts,std::string& fs);
  void         stl_prep(std::string pointsa, std::string pointsb, std::string pointsc, std::string &fs);
  AttributeMap& get_attributes();
  void         get_imgeo_attributes(std::wostream& of, std::string id);
  void         get_citygml_attributes(std::wostream& of, const AttributeMap& attributes);
  void         get_cityjson_attributes(nlohmann::json& f, const AttributeMap& attributes);
  void         cleanup_lidarelevs();
protected:
  Polygon2*                         _p2;
  std::vector< std::vector<int> >   _p2z;
  std::vector<TopoFeature*>*        _adjFeatures;
  std::string                       _id;
  bool                              _bVerticalWalls;
  bool                              _toplevel;
  std::string                       _layername;
  AttributeMap                      _attributes;

  std::vector< std::vector< std::vector<int> > >  _lidarelevs; //-- used to collect all LiDAR points linked to the polygon
  std::vector< std::pair<Point3, std::string> >   _vertices;
  std::vector<Triangle>                           _triangles;
  std::vector< std::pair<Point3, std::string> >   _vertices_vw;
  std::vector<Triangle>                           _triangles_vw;

  Point2  get_next_point2_in_ring(int ringi, int i, int& pi);
  bool    assign_elevation_to_vertex(const Point2& p, double z, float radius);
  bool    within_range(const Point2& p, double radius);
  bool    point_in_polygon(const Point2& p);
  void    lift_each_boundary_vertices(float percentile);
  void    lift_all_boundary_vertices_same_height(int height);

  void get_cityjson_geom(nlohmann::json& g, std::unordered_map<std::string, unsigned long>& dPts, std::string primitive = "MultiSurface");
  void get_triangle_as_gml_surfacemember(std::wostream& of, Triangle& t, bool verticalwall = false);
  void get_floor_triangle_as_gml_surfacemember(std::wostream& of, Triangle& t, int baseheight);
  void get_triangle_as_gml_triangle(std::wostream& of, Triangle& t, bool verticalwall = false);
  bool get_attribute(std::string attributeName, std::string &attribute, std::string defaultValue = "");
};

//---------------------------------------------

class Flat: public TopoFeature {
public:
  Flat(char* wkt, std::string layername, AttributeMap attributes, std::string pid);
  int                 get_number_vertices();
  bool                add_elevation_point(Point2& p, double z, float radius, int lasclass, bool within);
  int                 get_height();
  virtual TopoClass   get_class() = 0;
  virtual bool        is_hard() = 0;
  virtual bool        lift() = 0;
  virtual void        get_citygml(std::wostream& of) = 0;
  virtual void        get_cityjson(nlohmann::json& j, std::unordered_map<std::string, unsigned long>& dPts) = 0;
  virtual void        cleanup_elevations() = 0;
protected:
  std::vector<int>    _zvaluesinside;
  int                  _height_top;
  bool                lift_percentile(float percentile);
};

//---------------------------------------------

class Boundary3D: public TopoFeature {
public:
  Boundary3D(char* wkt, std::string layername, AttributeMap attributes, std::string pid);
  int                  get_number_vertices();
  bool                 add_elevation_point(Point2& p, double z, float radius, int lasclass, bool within);
  virtual TopoClass    get_class() = 0;
  virtual bool         is_hard() = 0;
  virtual bool         lift() = 0;
  virtual void         get_citygml(std::wostream& of) = 0;
  virtual void         get_cityjson(nlohmann::json& j, std::unordered_map<std::string, unsigned long>& dPts) = 0;
  virtual void         cleanup_elevations() = 0;
  void                 detect_outliers(bool replace_all, float max_outlier_fraction=0.2);
protected:
  int                  _simplification;
  void                 smooth_boundary(int passes = 1);
};

//---------------------------------------------

class TIN: public TopoFeature {
public:
  TIN(char* wkt, std::string layername, AttributeMap attributes, std::string pid, int simplification = 0, double simplification_tinsimp = 0, float innerbuffer = 0);
  int                 get_number_vertices();
  bool                add_elevation_point(Point2& p, double z, float radius, int lasclass, bool within);
  virtual TopoClass   get_class() = 0;
  virtual bool        is_hard() = 0;
  virtual bool        lift() = 0;
  virtual void        get_citygml(std::wostream& of) = 0;
  virtual void        get_cityjson(nlohmann::json& j, std::unordered_map<std::string, unsigned long>& dPts) = 0;
  virtual void        cleanup_elevations() = 0;
  bool                buildCDT();
protected:
  int                 _simplification;
  double              _simplification_tinsimp;
  float               _innerbuffer;
  std::vector<Point3> _lidarpts;
};

#endif 
